# Git 新手入门：从基础到协作的极简指南
本文按「基础准备→本地操作→远程协作→冲突解决」由浅入深拆解，只保留核心操作，新手掌握后可满足 90% 日常需求。


## 一、基础准备：3 步完成 Git 初始化
### 1. 安装 Git
- 下载：进入 [Git 官网](https://git-scm.com)，选择对应系统版本（Windows/Mac/Linux）。
- 安装：一路默认下一步（无需修改配置）。
- 验证：打开终端（Windows 用 PowerShell，Mac/Linux 用终端），输入 `git --version`，能显示版本号即成功。

### 2. 配置身份（仅需 1 次）
Git 会记录每次提交的作者，首次使用必须配置：
```bash
# 替换为你的名字（如 "Li Ming"）
git config --global user.name "你的名字"
# 替换为你的邮箱（如 "liming@example.com"）
git config --global user.email "你的邮箱"
```

### 3. 理解核心概念
- **工作区**：你正在编辑代码的文件夹（看得见的文件）。
- **暂存区**：临时存放修改的“过渡区”（用 `git add` 把工作区内容移入）。
- **本地仓库**：存放所有版本记录的数据库（用 `git commit` 把暂存区内容存入）。
- **远程仓库**：线上仓库（如 GitHub），用于多人共享代码。

在 Git 中，**提交（Commit）** 和**分支（Branch）** 是两个核心概念，它们共同构成了代码版本管理的基础，关系可以简单理解为：**提交是代码的“快照”，分支是提交的“容器”或“时间线”**。

## 二、理解提交与分支
### **1. 提交（Commit）：代码的快照**
每次执行 `git commit`，Git 都会对当前工作区的代码做一个**完整快照**，并生成一个唯一的标识符（哈希值，如 `a1b2c3d`）。可以把提交理解为：
- **时间点的代码状态**：就像给代码拍了一张照片，记录了此刻所有文件的内容。
- **不可修改的节点**：一旦提交，这个快照就永久保存，无法修改（后续修改会生成新的提交）。
- **包含上下文信息**：每个提交都包含作者、时间、提交信息（说明这次修改的目的），以及**指向父提交的指针**（形成历史链条）。

例如，一个简单的提交历史可能是：
```
初始提交 → 修复bug → 新增功能 → 优化性能（最新提交）
```
每个箭头都是一次提交，后一个提交会“记住”前一个提交（父节点），形成一条完整的历史线。


### **2. 分支（Branch）：提交的容器/时间线**
分支本质是一个**指向某个提交的指针**，它的作用是：
- **隔离开发线**：让不同的开发任务（如开发新功能、修复bug）在独立的时间线上进行，互不干扰。
- **标记当前进度**：分支默认指向该分支的**最新提交**，并会随着新提交自动向前移动。

例如：
- `main` 分支指向项目的稳定版本提交；
- `feature/payment` 分支指向“支付功能”开发的最新提交；
- `bugfix/login` 分支指向“登录bug修复”的最新提交。

分支的本质是“指针”，因此创建分支非常轻量（只是新建一个指针，不会复制文件）。


### **3. 提交与分支的关系**
- **分支包含一系列提交**：一个分支从创建到现在的所有提交，构成了这条分支的完整历史。例如 `main` 分支包含了从项目初始化到现在的所有提交。
- **多个分支可以共享部分提交**：当从 `main` 分支创建 `feature` 分支时，`feature` 会先共享 `main` 分支的所有历史提交，之后两个分支的新提交会各自独立。
  ```
  main:    A → B → C → D（最新）
               ↘
  feature:      → E → F（最新）
  ```
  （A、B 是两个分支共享的提交，C、D 是 `main` 独有的，E、F 是 `feature` 独有的）
- **提交不属于特定分支，但会被分支“引用”**：一个提交可以被多个分支同时指向（例如合并分支后），但只有当所有分支都不指向它时，这个提交才会成为“孤儿”（最终可能被 Git 清理）。


### **4. 通俗比喻**
- 把**提交**想象成“珠子”，每个珠子是一个代码版本。
- 把**分支**想象成“绳子”，绳子串起一系列珠子（提交），绳子的末端永远指向最后一颗珠子（最新提交）。
- 当创建新分支时，相当于从某个珠子处“复制出一根新绳子”，后续可以在新绳子上串新珠子（新提交），而不影响原来的绳子。


### **总结**
- 提交是代码的“历史节点”，记录具体的版本状态；
- 分支是提交的“组织方式”，通过指针管理一系列提交，实现开发隔离；
- 理解两者的关系，就能明白 Git 如何实现“多人协作”“多任务并行开发”和“版本回溯”。


## 三、本地仓库操作：自己管理代码的 4 个核心步骤
### 1. 新建本地仓库（从无到有）
适用于从零开发的项目：
```bash
# 1. 新建文件夹（如 "my-project"）并进入
mkdir my-project
cd my-project

# 2. 初始化 Git 仓库（生成隐藏的 .git 文件夹，勿删除）
git init
```

### 2. 日常代码管理（核心流程）
写代码后，按“查看→暂存→提交”三步保存版本：
```bash
# 1. 查看文件状态（红色=未暂存，绿色=已暂存）
git status

# 2. 暂存修改（推荐用 "." 暂存所有文件，也可指定单个文件如 "git add hello.py"）
git add .

# 3. 提交到本地仓库（必须写备注，说明改了什么）
git commit -m "备注内容"  # 例：git commit -m "新增登录功能"
```

### 3. 查看历史记录
想回顾之前的修改时使用：
```bash
# 简洁查看（一行一个版本，推荐）
git log --oneline

# 详细查看（包含作者、时间，按 "q" 退出）
git log
```

### 4. 撤销操作
| 场景 | 命令 | 说明 |
|------|------|------|
| 改乱文件，想恢复到上次提交状态 | `git checkout -- 文件名` | 例：`git checkout -- hello.py`（仅撤销工作区修改） |
| 暂存错文件（已 `git add`，想放回工作区） | `git reset HEAD 文件名` | 例：`git reset HEAD hello.py` |
| 回到某个历史版本 | `git reset --hard 版本号` | 版本号从 `git log --oneline` 中获取（如 `git reset --hard a1b2c3`） |


## 四、远程仓库协作：和他人共享代码（以 GitHub 为例）
### 1. 前期准备：关联远程仓库
适用于把本地代码推到 GitHub，或从 GitHub 拉取代码：
#### 场景 1：本地已有项目，推到新建的 GitHub 仓库
- 第一步：在 GitHub 新建仓库（勿勾选“Initialize with a README”），复制仓库地址（如 `https://github.com/你的账号/my-project.git`）。
- 第二步：在本地执行命令关联：
```bash
# 1. 关联远程仓库（命名为 "origin"，默认约定名）
git remote add origin 你的GitHub仓库地址

# 2. 把本地主分支改名为 "main"（GitHub 默认主分支名）
git branch -M main
```

#### 场景 2：克隆他人的 GitHub 仓库到本地
适用于接手已有项目：
```bash
# 复制 GitHub 仓库地址，执行克隆（会自动生成项目文件夹）
git clone 仓库地址  # 例：git clone https://github.com/他人账号/项目.git
```

### 2. 核心协作命令
| 操作 | 命令 | 说明 |
|------|------|------|
| 推本地代码到远程 | `git push -u origin main` | 首次推送用 `-u` 关联分支，后续直接用 `git push` |
| 拉远程最新代码到本地 | `git pull origin main` | 多人协作时，先拉取再修改，避免冲突 |

### 3. 分支操作（多人协作必备）
分支是“隔离开发”的关键（比如你开发新功能，不影响主分支，下面的bash命令以主仓库所有者的视角为例介绍分支操作）：
```bash
# 1. 查看所有分支（当前分支前有 "*"）
git branch

# 2. 新建并切换到分支（例：开发登录功能，分支名建议 "feature/功能名"）
git checkout -b feature/login

# 3. 在分支上开发、提交后，推到远程分支
git push -u origin feature/login

# 4. 功能完成后，合并到主分支
git checkout main  # 切回主分支
git merge feature/login  # 合并分支代码
git push origin main  # 推到远程主分支

# 5. （可选）删除已合并的本地分支
git branch -d feature/login
```


## 五、冲突解决：多人改同一文件怎么办？
### 1. 冲突是什么？
当两人修改了**同一文件的同一部分**（如 A 改第 10 行，B 也改第 10 行），Git 无法自动判断保留哪部分，就会产生冲突。

### 2. 解决冲突的 6 步流程（以开发者 B 为例）
假设 A 已把代码合并到主分支，B 提交时提示冲突：
```bash
# 步骤 1：切到自己的功能分支（如 feature/B）
git checkout feature/B

# 步骤 2：拉取主分支最新代码（假设远程主仓库叫 "upstream"）
git fetch upstream

# 步骤 3：合并主分支到自己的分支（触发冲突）
git merge upstream/main
# 终端会提示：Conflict in 冲突文件名（如 user.js）

# 步骤 4：手动编辑冲突文件
# 打开冲突文件（如 user.js），会看到 Git 标记的冲突部分：
<<<<<<< HEAD  # 你的修改（feature/B 分支）
let name = "李四";
=======  # 分隔线：上方是你的修改，下方是主分支修改
let name = "张三";
>>>>>>> upstream/main  # 主分支修改
# 处理：保留正确内容，删除冲突标记（<<<<<<<、=======、>>>>>>>）
# 例：最终保留 let name = "张三";

# 步骤 5：提交解决后的代码
git add .  # 暂存修改
git commit -m "解决与主分支的冲突：统一用户名"

# 步骤 6：推到远程，更新 PR（Pull Request）
git push origin feature/B
```

### 3. 避免冲突的小技巧
- 频繁同步：每天开发前拉取主分支最新代码（`git pull upstream main`）。
- 小步提交：尽量把大功能拆成小修改，减少同一文件的修改范围。
- 提前沟通：和队友确认谁改哪个文件，避免同时改同一部分。


## 六、核心流程总结
1. **单人开发**：写代码 → `git add .` → `git commit -m "备注"` → `git push`。
2. **多人协作**：拉取最新代码（`git fetch`+`git log upstream/main`+`git merge` 或 直接`git pull`）→ 新建分支开发 → 提交代码 → 发起 PR → 解决冲突 → 合并分支。

新手先练熟本地操作和远程推拉，再学分支和冲突，循序渐进即可。


## 七、分支操作的流程确实会因角色不同（主仓库所有者 vs 协作者）而略有差异。

### 一、主仓库所有者的分支操作逻辑（直接维护主仓库）
如果你是项目负责人，直接拥有主仓库的修改权限，流程是：
```bash
# 1. 查看当前分支（确认在主分支或其他分支）
git branch  # 确保了解当前工作环境

# 2. 新建功能分支（从主分支分叉，避免直接修改主分支）
git checkout -b feature/login  # 基于 main 分支创建新分支
# 逻辑：主分支需要保持稳定，新功能在独立分支开发更安全

# 3. 开发完成后推到远程（备份+方便团队查看）
git push -u origin feature/login  # 远程会创建同名分支
# 逻辑：即使是主仓库所有者，也建议先推分支再合并，方便留痕和审核

# 4. 功能确认无误后，合并到主分支
git checkout main  # 切回主分支（要接收新功能的目标分支）
git merge feature/login  # 把开发好的功能合并进主分支
git push origin main  # 同步到远程主分支，让所有人获取最新版本
# 逻辑：主分支是项目"正式版本"，只有确认无误的功能才合并进来

# 5. 删除无用分支（保持仓库整洁）
git branch -d feature/login  # 功能已合并，分支使命完成
```

**核心逻辑**：主仓库所有者有直接修改主分支的权限，但仍通过分支隔离开发，避免主分支被临时代码污染。


### 二、协作者（Fork 仓库）的分支操作逻辑（间接参与）
如果你是通过 Fork 主仓库参与开发的协作者（没有主仓库直接修改权限），流程会有差异：
```bash
# 前期准备：Fork 主仓库后，克隆到本地并关联上游
git clone https://github.com/自己账号/项目.git  # 克隆自己 Fork 的仓库
cd 项目
git remote add upstream https://github.com/主仓库账号/项目.git  # 关联主仓库

# 1. 开始开发前，确保本地主分支与上游同步
git checkout main
git fetch upstream  # 拉取主仓库最新代码
git merge upstream/main  # 同步到本地主分支

# 2. 从同步后的主分支新建功能分支（基于最新代码开发）
git checkout -b feature/login  # 此时分支起点是主仓库的最新版本

# 3. 开发、提交后，推到自己的远程仓库（而非主仓库）
git push -u origin feature/login  # 推到自己 Fork 的仓库

# 4. 功能完成后，先在本地合并主仓库最新代码（避免冲突）
git fetch upstream  # 拉取主仓库可能的新更新
git merge upstream/main  # 合并到自己的功能分支（解决冲突）

# 5. 推送更新后的功能分支，然后在 GitHub 发起 PR（请求合并到主仓库）
git push origin feature/login  # 更新自己的远程分支
# （在 GitHub 上操作：从自己的 feature/login 分支 向 主仓库的 main 分支 发 PR）

# 6. 主仓库合并 PR 后，协作者清理本地分支
git checkout main
git pull upstream main  # 同步主仓库最新代码
git branch -d feature/login  # 删除本地功能分支
```

**核心差异**：  
协作者没有主仓库的直接修改权限，所以：  
- 不能直接推代码到主仓库的 `main` 分支  
- 必须通过 PR 请求主仓库维护者合并  
- 合并前要先同步主仓库最新代码（避免 PR 冲突）  


### 总结：两种角色的核心区别
| 操作 | 主仓库所有者 | 协作者（Fork） |
|------|------------|--------------|
| 最终合并目标 | 直接合并到自己仓库的 `main` 分支 | 只能通过 PR 请求合并到主仓库的 `main` 分支 |
| 推送对象 | 直接推到主仓库的分支 | 只能推到自己 Fork 仓库的分支 |
| 权限基础 | 拥有主仓库的写权限 | 只有自己 Fork 仓库的写权限，主仓库只有读权限 |

两种流程的本质都是**通过分支隔离开发**，只是最终合并到主仓库的方式不同（直接合并 vs PR 请求）。

## 八、git fetch + git merge与git pull的区别

`git fetch + git merge` 是显式拆分两步操作，而 `git pull` 是 `fetch + merge` 的**自动组合操作**，用前者的核心目的是**先查看上游变更、再自主决定是否/如何合并**，避免直接 `pull` 可能带来的意外冲突或代码覆盖。


### 1. 本质区别：“可控” vs “自动”
| 操作组合 | 核心逻辑                                                                                                                                                | 适用场景 |
|----------|-----------------------------------------------------------------------------------------------------------------------------------------------------|----------|
| `git fetch upstream` + `git merge upstream/main` | 1. **先拉取不合并**：仅把上游（主仓库）的最新代码下载到本地“缓存区”（`upstream/main`），不影响当前工作区代码；<br>2. **再手动合并**：合并前可先通过 `git log upstream/main` 查看上游具体改了什么（查看上游全部历史），确认无风险后再合并。 | 协作场景（如你作为协作者同步主仓库代码）：需先了解上游变更，避免盲目合并导致冲突或覆盖本地代码。 |
| `git pull upstream main` | 一步完成“拉取上游代码 + 直接合并到当前分支”，中间**无人工确认环节**。                                                                                                             | 个人独立开发、确认上游代码无冲突时：追求效率，可直接用。 |


### 2. 为什么协作时推荐 `fetch + merge`？
以你“协作者同步主仓库代码”的场景为例：  
如果直接用 `git pull upstream main`，上游代码会**自动合并**到你当前的 `main` 分支。若上游代码和你本地 `main` 有冲突，Git 会直接进入“冲突解决模式”，新手可能因不清楚冲突来源（上游具体改了哪行）而误操作。  

而用 `git fetch` 后，你可以先执行 `git log main..upstream/main` 查看上游主分支比你本地多了哪些提交，明确变更内容后再执行 `git merge`，冲突时能更精准地解决，风险更低。